class Disjoint{
    int[] parent;
    int[] size;
    Disjoint(int n){
        parent = new int[n];
        size = new int[n];
        for(int i=0;i<n;i++){
            parent[i] = i;
            size[i] = 1;
        }
    }
    int findParent(int x){
        if(x==parent[x]) return x;
        return parent[x] = findParent(parent[x]);
    }
    void unionBySize(int u,int v){
        int pu = findParent(u);
        int pv = findParent(v);
        if(pu==pv) return;
        if(size[pu] < size[pv]){
            parent[pu] = pv;
            size[pv]+=size[pu];
        }else{
            parent[pv] = pu;
            size[pu]+=size[pv];
        }
    }
}
class Solution {
    public int removeStones(int[][] stones) {
        int x = stones[0][0];
        int y = stones[0][1];
        int n = stones.length;
        for(int i=1;i<n;i++){
            x = Math.max(x,stones[i][0]);
            y = Math.max(y,stones[i][1]);
        }
        Disjoint ds = new Disjoint((x+y+2));
        HashMap<Integer,Integer> hm = new HashMap<>();
        for(int i=0;i<n;i++){
            int u = stones[i][0];
            int v = stones[i][1];
            v+= x+1;
            ds.unionBySize(u,v);
            hm.put(u,1);
            hm.put(v,1);
        }
        int cnt=0;
        for(int i:hm.keySet()){
            if(ds.findParent(i)==i) cnt++;
        }
        return n-cnt;
    }
}
TIME COMPLEXITY - O(n)
SPACE COMPLEXITY - O(n)
