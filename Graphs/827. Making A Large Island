class Disjoint{
    int[] parent;
    int[] size;
    Disjoint(int n){
        parent = new int[n];
        size = new int[n];
        for(int i=0;i<n;i++){
            size[i] = 1;
            parent[i] = i;
        }
    }
    int findParent(int x){
        if(x==parent[x]) return x;
        return parent[x] = findParent(parent[x]);
    }
    void unionBySize(int u,int v){
        int pu = findParent(u);
        int pv = findParent(v);
        if(pu==pv) return;
        if(size[pu] < size[pv]){
            parent[pu] = pv;
            size[pv]+=size[pu];
        }else{
            parent[pv] = pu;
            size[pu]+=size[pv];
        }
    }
}
class Solution {
    public int largestIsland(int[][] grid) {
        int n = grid.length;
        Disjoint ds = new Disjoint(n*n);
        int[] dx = {-1,0,1,0};
        int[] dy = {0,-1,0,1};
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==1){
                    for(int it=0;it<4;it++){
                        int newx = i+dx[it];
                        int newy = j+dy[it];
                        if(newx>=0 && newy>=0 && newx<n && newy<n && grid[newx][newy]==1){
                            int node = i*n+j;
                            int adjNode = newx*n+newy;
                            ds.unionBySize(node,adjNode);
                        }
                    }
                }
            }
        }
        int maxi = 0;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                HashSet<Integer> hs = new HashSet<>();
                if(grid[i][j]==0){
                    for(int it=0;it<4;it++){
                        int newx = i+dx[it];
                        int newy = j+dy[it];
                        if(newx>=0 && newy>=0 && newx<n && newy<n && grid[newx][newy]==1){
                            int node = newx*n+newy;
                            hs.add(ds.findParent(node));
                        }
                    }
                }
                int total = 0;
                for(int ii:hs) total+=ds.size[ii];
                maxi = Math.max(total+1,maxi);
            }
        }
        for(int i=0;i<n*n;i++){
            maxi = Math.max(maxi,ds.size[ds.findParent(i)]);
        }
        return maxi;
    }
}
TIME COMPLEXITY - O(n*n)
SPACE COMPLEXITY - O(n*n)
