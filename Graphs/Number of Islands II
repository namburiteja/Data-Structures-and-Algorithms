public class Solution {
    static class Disjoint{
        int[] rank;
        int[] parent;
        Disjoint(int n){
            rank = new int[n];
            parent = new int[n];
            for(int i=0;i<n;i++) parent[i] = i;
        }
        int findParent(int x){
            if(x==parent[x]) return x;
            return parent[x] = findParent(parent[x]);
        }
        void union(int u,int v){
            int pu = findParent(u);
            int pv = findParent(v);
            if(pu==pv) return;
            if(rank[pu] < rank[pv]) parent[pu] = pv;
            else if(rank[pv] < rank[pu]) parent[pv] = pu;
            else{
                parent[pv] = pu;
                rank[pu]++;
            }
        }
    }
    public static int[] numOfIslandsII(int n, int m, int[][] q) {
        int xx = q.length;
        Disjoint ds = new Disjoint(n*m);
        int[] res = new int[xx];
        int[][] vis = new int[n][m];
        int cnt = 0;
        for(int i=0;i<xx;i++){
            int x = q[i][0];
            int y = q[i][1];
            if(vis[x][y]==1){
                res[i] = cnt;
                continue;
            } 
            vis[x][y] = 1;
            cnt++;
            int[] dx = {-1,0,1,0};
            int[] dy = {0,-1,0,1};
            for(int it=0;it<4;it++){
                int newx = x+dx[it];
                int newy = y+dy[it];
                if(newx>=0 && newy>=0 && newx<n && newy<m){
                    if(vis[newx][newy]==1){
                        int nodeno = x*m+y;
                        int adjnodeno = newx*m+newy;
                        if(ds.findParent(nodeno) != ds.findParent(adjnodeno)){
                            cnt--;
                            ds.union(nodeno,adjnodeno);
                        }
                    }
                }
            }
            res[i] = cnt;
        }
        return res;
    }
}
TIME COMPLEXITY - O(N*N)
SPACE COMPLEXITY - O(N*N)
